# 1、函数模版入门

我们知道，数据的值可以通过函数参数传递，在函数定义时数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。这就是值的参数化。

在C++中，数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化。

值（Value）和类型（Type）是数据的两个主要特征，它们在C++中都可以被参数化。

所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为函数模板（Function Template）。

在函数模板中，数据的值和类型都被参数化了，发生函数调用时编译器会根据传入的实参来推演形参的值和类型。换个角度说，函数模板除了支持值的参数化，还支持类型的参数化。

一但定义了函数模板，就可以将类型参数用于函数定义和函数声明了。说得直白一点，原来使用 int、float、char 等内置类型的地方，都可以用类型参数来代替。

# 2、C++函数模板的实参推断
对于函数模板，调用函数时可以不显式地指明实参（也就是具体的类型）。请看下面的例子：
```cpp
//函数声明
template<typename T> void Swap(T &a, T &b);
//函数调用
int n1 = 100, n2 = 200;
Swap(n1, n2);
float f1 = 12.5, f2 = 56.93;
Swap(f1, f2);
```
虽然没有显式地指明 T 的具体类型，但是编译器会根据 n1 和 n2、f1 和 f2 的类型自动推断出 T 的类型。这种通过函数实参来确定模板实参（也就是类型参数的具体类型）的过程称为模板实参推断。

在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找类型参数的具体类型。

对于普通函数（非模板函数），发生函数调用时会对实参的类型进行适当的转换，以适应形参的类型。这些转换包括：

算数转换：例如 int 转换为 float，char 转换为 int，double 转换为 int 等。

派生类向基类的转换：也就是向上转型。

const 转换：也即将非 const 类型转换为 const 类型，例如将 char * 转换为 const char *。

数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。
用户自定的类型转换。

# 3、C++模板的显式具体化（模板特例化）
